# DjangoLearning Tutorial 4.0
***
## previous work

* check django version
    ```python
    python -m django --version
    ```
* create a project
    ```python
    django-admin startproject mysite
    ```
    Do this step will create a directory named mysite with some files inside it.
    The 'mysite' can be changed by any name you want.
* runserver
    ```python
    python manage.py runserver
    ```
* check your broswer
    ```python
    http://127.0.0.1:8000/
    ```
* create an app
    ```python
    python manage.py startapp polls
    ```
    Do this step will create a directory named polls with some files inside it.
    The 'polls' can be changed by any name you want.
* create the first view
    ```python
    # polls/views.py
    from django.http import HttpResponse


    def index(request):
        return HttpResponse("Hello, world. You're at the polls index.")
    ```
* create a URLconf for polls app
    create a file named urls.py in dictionary polls
* set url mapping
    * in project mysite
        ```python
        from django.contrib import admin
        from django.urls import include, path

        urlpatterns = [
            path('polls/', include('polls.urls')),
            path('admin/', admin.site.urls),
        ]
        ```
    * in app polls
        ```python
        from django.urls import path

        from . import views

        urlpatterns = [
            path('', views.index, name='index'),
        ]    
        ```
* check your broswer
    ```python
    http://127.0.0.1:8000/polls
    ```
## database and model

* database setup
    In official documentation, SQLite is used as database.
    I will use MySQL as the database of the project.
    I need three steps to connect Django with MySQL.
    * change the setting file
        ```python
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.mysql',
                'NAME': 'mysite',
                'USER': 'root',
                'PASSWORD': '123456',
                'HOST': '127.0.0.1',
                'PORT': '3306',
            }
        }  
        ```
    * install pymysql
    in terminal
        ```python
        pip install pymysql
        ```
    * modify the __init__.py file in project
* create tables in database
    * why create tables
        Django integrated 6 app helps us developing conveniencly.
        However, some of these applications make use of at least one database table, though, so we need to create the tables in the database before we can use them. 
    * step one
        ```python
        python manage.py migrate
        ```
        Doing this, several tables will be created in our database by django.
* create models
    * why create models
        A model in django maps a table in database.
        Our data need to be stored in database by model.
    * modify polls/models.py
        ```python
        from django.db import models


        class Question(models.Model):
            question_text = models.CharField(max_length=200)
            pub_date = models.DateTimeField('date published')


        class Choice(models.Model):
            question = models.ForeignKey(Question, on_delete=models.CASCADE)
            choice_text = models.CharField(max_length=200)
            votes = models.IntegerField(default=0)
        ```
* activationg models
    * First we need to tell our project that the polls app is installed.
       We need to modify the project settings.py.
       ```python
        INSTALLED_APPS = [
            'polls.apps.PollsConfig',
            'django.contrib.admin',
            'django.contrib.auth',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.messages',
            'django.contrib.staticfiles',
        ]
       ``` 
    * then run another command
        ```python
        python manage.py makemigrations polls
        ```
        By running makemigrations, you’re telling Django that you’ve made some changes to your models (in this case, you’ve made new ones) and that you’d like the changes to be stored as a migration.
        We can find that
        ```python
        Migrations for 'polls':
        polls\migrations\0001_initial.py
            - Create model Question       
            - Create model Choice          
        ```
        in terminal
        Besides, 0001_initial.py file was created by django, which content is that:
        ```python
        # Generated by Django 3.2.10 on 2022-03-16 08:53

        from django.db import migrations, models
        import django.db.models.deletion


        class Migration(migrations.Migration):

            initial = True

            dependencies = [
            ]

            operations = [
                migrations.CreateModel(
                    name='Question',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('question_text', models.CharField(max_length=200)),
                        ('pub_date', models.DateTimeField(verbose_name='date published')),
                    ],
                ),
                migrations.CreateModel(
                    name='Choice',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('choice_text', models.CharField(max_length=200)),
                        ('votes', models.IntegerField(default=0)),
                        ('question', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='polls.question')),
                    ],
                ),
            ]
                
        ```
    * then run this command to see what SQL that migration would run
        ```python
            python manage.py sqlmigrate polls 0001
        ```
        we can see SQL in terminal
        ```sql
        --                      
        -- Create model Question
        --                      
        CREATE TABLE `polls_question` (`id` bigint AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT
        NULL, `pub_date` datetime(6) NOT NULL);
        --
        -- Create model Choice
        --
        CREATE TABLE `polls_choice` (`id` bigint AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NUL
        L, `votes` integer NOT NULL, `question_id` bigint NOT NULL);
        ALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (
        `question_id`) REFERENCES `polls_question` (`id`);

        ```
        Note that :The sqlmigrate command doesn’t actually run the migration on your database - instead, it prints it to the screen so that you can see what SQL Django thinks is required. 
    * run migrate again to create those model tables in your database
        ```python
        python manage.py migrate
        ```
        Now two new tables polls_choice and polls_question have been created in database by django.
* use API
    * open django shell
        ```python
        python manage.py shell
        ```
    * use shell to conveniently use API
        ```python
        >>> from polls.models import Choice, Question  # Import the model classes we just wrote.

        # No questions are in the system yet.
        >>> Question.objects.all()
        <QuerySet []>

        # Create a new Question.
        # Support for time zones is enabled in the default settings file, so
        # Django expects a datetime with tzinfo for pub_date. Use timezone.now()
        # instead of datetime.datetime.now() and it will do the right thing.
        >>> from django.utils import timezone
        >>> q = Question(question_text="What's new?", pub_date=timezone.now())

        # Save the object into the database. You have to call save() explicitly.
        >>> q.save()

        # Now it has an ID.
        >>> q.id
        1

        # Access model field values via Python attributes.
        >>> q.question_text
        "What's new?"
        >>> q.pub_date
        datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

        # Change values by changing the attributes, then calling save().
        >>> q.question_text = "What's up?"
        >>> q.save()

        # objects.all() displays all the questions in the database.
        >>> Question.objects.all()
        <QuerySet [<Question: Question object (1)>]>    
        ```
    * \__str__() method in models
        ```python
        from django.db import models

        class Question(models.Model):
            # ...
            def __str__(self):
                return self.question_text

        class Choice(models.Model):
            # ...
            def __str__(self):
                return self.choice_text        
        ```
* create an admin user
    * first of all, create a admin user
    ```python
    python manage.py createsuperuser
    ```
    * then follow the prompts to register
    * start the development server
    ```python
    python manage.py runserver
    ```
    * check your broswer
    ```python
    http://127.0.0.1:8000/admin/
    ```
* use of admin site
    * enter the admin site
    enter your name and password
    * make the poll app modifiable in the admin
    ```python
    #polls/admin.py
    from django.contrib import admin

    from .models import Question

    admin.site.register(Question)
    ```
* focus on views
    * write more views
    ```python
    #polls/views.py
    def detail(request, question_id):
        return HttpResponse("You're looking at question %s." % question_id)

    def results(request, question_id):
        response = "You're looking at the results of question %s."
        return HttpResponse(response % question_id)

    def vote(request, question_id):
        return HttpResponse("You're voting on question %s." % question_id)
    ```
    * modify polls.urls
    ```python
    from django.urls import path

    from . import views

    urlpatterns = [
        path('', views.index, name='index'),
        path('<int:question_id>/', views.detail, name='detail'),
        path('<int:question_id>/results/', views.results, name='results'),
        path('<int:question_id>/vote/', views.vote, name='vote'),
    ]
    ```
* check your broswer
    ```python
    http://127.0.0.1:8000/polls/15
    http://127.0.0.1:8000/polls/15/results/
    http://127.0.0.1:8000/polls/15/vote/
    ```
* What a view really do?
Each view is responsible for doing one of two things: **returning an HttpResponse** object containing the content for the requested page, or **raising an exception** such as Http404. The rest is up to you.

* let views do more things
    * rewrite index() function
        ```python
        #polls/views.py
        def index(request):
            latest_question_list = Question.objects.order_by('-pub_date')[:5]
            output = ', '.join([q.question_text for q in latest_question_list])
            return HttpResponse(output)
        ```
    * check your broswer
    ```python
    http://127.0.0.1:8000/polls/
    ``` 
## templates
* create a directory called templates in your polls directory.
Django will look for templates in there.
* **APP_DIRS**
Default: False
Whether the engine should look for template source files inside installed applications.
* Within the templates directory you have just created, create another directory called polls, and within that create a file called index.html. In other words, your template should be at polls/templates/polls/index.html. 
Because of how the app_directories template loader works as described above, you can refer to this template within Django as polls/index.html.
* Template namespacing
Now we might be able to get away with putting our templates directly in polls/templates (rather than creating another polls subdirectory), but it would actually be a bad idea. Django will choose the first template it finds whose name matches, and if you had a template with the same name in a different application, Django would be unable to distinguish between them. We need to be able to point Django at the right one, and the best way to ensure this is by namespacing them. That is, by putting those templates inside another directory named for the application itself.
* write polls/index.html
    ```python
    {% if latest_question_list %}
        <ul>
        {% for question in latest_question_list %}
            <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p>
    {% endif %}
    ```
* rewrite index in polls.views.py
    ```python
    def index(request):
        latest_question_list = Question.objects.order_by('-pub_date')[:5]
        template = loader.get_template('polls/index.html')
        context = {'latest_question_list':latest_question_list}
        return HttpResponse(template.render(context,request))  
    ```
    That code loads the template called polls/index.html and passes it a context. 
    The context is a dictionary mapping template variable names to Python objects.
* check your broswer
    ```python
    http://127.0.0.1:8000/polls/
    ``` 
* a shortcut render() method
rewrite index in polls/views.py
    ```python
    def index(request):
        latest_question_list = Question.objects.order_by('-pub_date')[:5]
        context = {'latest_question_list': latest_question_list}
        return render(request, 'polls/index.html', context)
    ```
The render() function takes the request object as its first argument, a template name as its second argument and a dictionary as its optional third argument. It returns an HttpResponse object of the given template rendered with the given context.
* Raising a 404 error
    * rewrite detail in polls/views.py
        ```python
        try:
            question = Question.objects.get(pk=question_id)
        except Question.DoesNotExist:
            raise Http404("Question does not exist")
        return render(request, 'polls/detail.html', {'question': question})    
        ```
    * create templates/polls/detail.html
        ```python
        {{ question }}
        ```
    * check your broswer
        ```python
        http://127.0.0.1:8000/polls/3
        ``` 
* a shortcut : get_object_or_404()
It’s a very common idiom to use get() and raise Http404 if the object doesn’t exist. Django provides a shortcut.
    * rewrite detail() in polls/views.py
        ```python
        question = get_object_or_404(Question, pk=question_id)
        return render(request, 'polls/detail.html', {'question': question})
        ```
    * Why do we use a helper function get_object_or_404() instead of automatically catching the ObjectDoesNotExist exceptions at a higher level, or having the model API raise Http404 instead of ObjectDoesNotExist?
    Because that would couple the model layer to the view layer. One of the foremost design goals of Django is to maintain loose coupling. Some controlled coupling is introduced in the django.shortcuts module.
    There’s also a get_list_or_404() function, which works just as get_object_or_404() – except using filter() instead of get(). It raises Http404 if the list is empty.
* thinking about the use of url
    * Now, we use a hardcoded url in template, details are as follow:
        ```python
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
        ```
        /polls/ is hardcoded url
    * The problem with this hardcoded, tightly-coupled approach is that it becomes challenging to change URLs on projects with a lot of templates.
    * However, since you defined the name argument in the path() functions in the polls.urls module, you can remove a reliance on specific URL paths defined in your url configurations by using the {% url %} template tag:
        ```python
        <li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
        ```
    * now, we can change url in views.py only once, and url in templates will change follow it.
        ```python
        path('specifics/<int:question_id>/', views.detail, name='detail'),
        ```
    * Namespacing URL names
    Conflictions will appear if different apps set their urls' name with detail.
    How does Django differentiate the URL names between them?
    * The answer is to add namespaces to your URLconf. In the polls/urls.py file, go ahead and add an app_name to set the application namespace:
        ```python
        from django.urls import path

        from . import views

        app_name = 'polls'
        urlpatterns = [
            path('', views.index, name='index'),
            path('<int:question_id>/', views.detail, name='detail'),
            path('<int:question_id>/results/', views.results, name='results'),
            path('<int:question_id>/vote/', views.vote, name='vote'),
        ]
        ```
    * Now change your polls/index.html template from:
        ```python
        <li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
        ```
        to point at the namespaced detail view:
        ```python
        <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
        ```
## form processing
* form in django
    * Write a minimal form vote.html
        ```python
        <form action="{% url 'polls:vote' question.id %}" method="post">
        {% csrf_token %}
        <fieldset>
            <legend><h1>{{ question.question_text }}</h1></legend>
            {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
            {% for choice in question.choice_set.all %}
                <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
                <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
            {% endfor %}
        </fieldset>
        <input type="submit" value="Vote">
        </form>    
        ```
        something important:
        * forloop.counter indicates how many times the for tag has gone through its loop
        * Since we’re creating a POST form (which can have the effect of modifying data), we need to worry about Cross Site Request Forgeries. Thankfully, you don’t have to worry too hard, because Django comes with a helpful system for protecting against it. In short, all POST forms that are targeted at internal URLs should use the {% csrf_token %} template tag.
    * rewrite vote() in polls/views.py
        ```python
        def vote(request, question_id):
            question = get_object_or_404(Question, pk=question_id)
            try:
                selected_choice = question.choice_set.get(pk=request.POST['choice'])
            except (KeyError, Choice.DoesNotExist):
                # Redisplay the question voting form.
                return render(request, 'polls/detail.html', {
                    'question': question,
                    'error_message': "You didn't select a choice.",
                })
            else:
                selected_choice.votes += 1
                selected_choice.save()
                # Always return an HttpResponseRedirect after successfully dealing
                # with POST data. This prevents data from being posted twice if a
                # user hits the Back button.
                return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
        ```
    * rewrite results() in polls/views.py
        ```python
        def results(request, question_id):
            question = get_object_or_404(Question, pk=question_id)
            return render(request, 'polls/results.html', {'question': question})
        ```
    * create a polls/results.html template
        ```python
        <h1>{{ question.question_text }}</h1>

        <ul>
        {% for choice in question.choice_set.all %}
            <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
        {% endfor %}
        </ul>

        <a href="{% url 'polls:detail' question.id %}">Vote again?</a>
        ```
    * check your broswer
        ```python
        http://127.0.0.1:8000/polls/3
        ```
    * **race condition**
    The code for our vote() view does have a small problem. It first gets the selected_choice object from the database, then computes the new value of votes, and then saves it back to the database. If two users of your website try to vote at exactly the same time, this might go wrong: The same value, let’s say 42, will be retrieved for votes. Then, for both users the new value of 43 is computed and saved, but 44 would be the expected value.
## Use generic views
These views represent a common case of basic web development: getting data from the database according to a parameter passed in the URL, loading a template and returning the rendered template. Because this is so common, Django provides a shortcut, called the “**generic views**” system.